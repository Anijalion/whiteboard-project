<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ å¯¾å¿œ -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>å…ç«¥ç”¨ - Whiteboard</title>
  <style>
    html, body {
      margin: 0; padding: 0; box-sizing: border-box;
      width: 100%; height: 100%; background: #ddd;
      overflow: hidden; font-family: sans-serif;
    }
    /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
    #toolbar {
      position: absolute; top: 0; left: 0; right: 0;
      display: flex; flex-wrap: wrap; gap: 8px;
      justify-content: center; align-items: center;
      background: rgba(0,0,0,0.2); padding: 4px; z-index: 10;
    }
    #toolbar button, #toolbar label {
      padding: 8px; cursor: pointer;
      background: #008b8b; color: white;
      border: none; border-radius: 4px; font-size: 14px;
    }
    /* ä½¿ç”¨ä¸­ã®ãƒ„ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ï¼ˆmousedownã§å³ activeï¼‰ */
    #toolbar button.active {
      background: darkorange;
    }
    #toolbar button:hover, #toolbar label:hover { background: #006868; }
    #photoInput { display: none; }
    /* è¿½åŠ ï¼šå†™çœŸã‚µã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ */
    #photoSizeBtn {
      padding: 8px; cursor: pointer;
      background: #008b8b; color: white;
      border: none; border-radius: 4px; font-size: 14px;
    }
    #photoSizeBtn.active {
      background: darkorange;
    }
    /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠï¼ˆå›ºå®šã‚µã‚¤ã‚º800Ã—600ï¼‰ */
    #canvasContainer {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 800px; height: 600px;
      border: 2px solid #aaa; background: #fff;
      position: relative;
    }
    /* ä¸‹å±¤ï¼šå†™çœŸç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ */
    #photoCanvas,
    /* ä¸Šå±¤ï¼šæç”»ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ */
    #drawCanvas {
      position: absolute; top: 0; left: 0;
      width: 800px; height: 600px;
      touch-action: none;
    }
    #photoCanvas { z-index: 1; }
    #drawCanvas { z-index: 2; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="penBlack">âš«ï¸</button>
    <button id="penRed">ğŸ”´</button>
    <button id="penBlue">ğŸ”µ</button>
    <button id="eraserBtn">ã‘ã—ã‚´ãƒ </button>
    <button id="undoBtn">â†ã‚‚ã©ã‚‹</button>
    <button id="redoBtn">ã™ã™ã‚€â†’</button>
    <button id="clearLocalBtn">ãœã‚“ã¶ã‘ã™</button>
    <label for="photoInput" id="photoLabel">ã—ã‚ƒã—ã‚“</label>
    <input type="file" accept="image/*" id="photoInput">
    <!-- æ–°è¦è¿½åŠ ï¼šå†™çœŸã‚µã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ -->
    <button id="photoSizeBtn">å†™çœŸã‚µã‚¤ã‚º: å…ƒ</button>
    <button id="lassoBtn">æŠ•ã’ç¸„ãƒ„ãƒ¼ãƒ«</button>
  </div>

  <div id="canvasContainer">
    <canvas id="photoCanvas" width="800" height="600"></canvas>
    <canvas id="drawCanvas" width="800" height="600"></canvas>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    /*********************
     * åŸºæœ¬è¨­å®š
     *********************/
    const roomID = prompt("ãƒ«ãƒ¼ãƒ ID?") || "";
    const userID = prompt("ã‚ãªãŸã®åå‰?") || "";
    let joined = (roomID && userID) ? true : false;
    let isLocked = false;
    let currentColor = "black";
    let drawing = false;
    
    const photoCanvas = document.getElementById("photoCanvas");
    const photoCtx = photoCanvas.getContext("2d");
    const drawCanvas = document.getElementById("drawCanvas");
    const drawCtx = drawCanvas.getContext("2d");
    
    photoCanvas.width = 800; photoCanvas.height = 600;
    drawCanvas.width = 800; drawCanvas.height = 600;
    
    let paths = [];        // æç”»ç·šã®é…åˆ—
    let undoStack = [];    // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆé…åˆ—
    let redoStack = [];
    
    // å†™çœŸæƒ…å ±ï¼šå„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ { img, imgSrc, x, y, width, height, scale }
    let photoObjs = [];
    
    // å†™çœŸã‚µã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ï¼š true = ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ•ã‚£ãƒƒãƒˆ, false = å…ƒã‚µã‚¤ã‚º
    let photoFitMode = false;
    document.getElementById("photoSizeBtn").addEventListener("mousedown", () => {
      photoFitMode = !photoFitMode;
      document.getElementById("photoSizeBtn").textContent = photoFitMode ? "å†™çœŸã‚µã‚¤ã‚º: ãƒ•ã‚£ãƒƒãƒˆ" : "å†™çœŸã‚µã‚¤ã‚º: å…ƒ";
      document.getElementById("photoSizeBtn").classList.toggle("active", photoFitMode);
    });
    
    /*********************
     * æŠ•ã’ç¸„ãƒ„ãƒ¼ãƒ«ç”¨ï¼ˆçŸ©å½¢é¸æŠï¼‰
     *********************/
    let isLassoMode = false;
    let isDraggingRect = false;
    let selectRect = null;            // ç¾åœ¨ã®é¸æŠçŸ©å½¢ { x, y, w, h }
    let selectRectOrig = null;        // pointerdown æ™‚ã®é¸æŠçŸ©å½¢ï¼ˆå›ºå®šåŸç‚¹ã¨ã‚µã‚¤ã‚ºï¼‰
    let selectMode = null;            // "move" ã¾ãŸã¯ "scale"
    let lastDragPos = null;           // å‰å›ã®ãƒã‚¤ãƒ³ã‚¿ä½ç½®ï¼ˆã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«æ›´æ–°ç”¨ï¼‰
    let selectedPaths = [];
    let selectedPhotos = [];
    
    const socket = io();
    if (joined) {
      socket.emit("joinRoom", { roomID, userID, isTeacher: false });
    }
    
    /*********************
     * ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆmousedownã§å³ activeï¼‰
     *********************/
    function updateToolButtons(activeId) {
      const btnIds = ["penBlack", "penRed", "penBlue", "eraserBtn", "lassoBtn"];
      btnIds.forEach(id => {
        const btn = document.getElementById(id);
        if (id === activeId) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });
    }
    document.getElementById("penBlack").addEventListener("mousedown", () => {
      currentColor = "black";
      updateToolButtons("penBlack");
    });
    document.getElementById("penRed").addEventListener("mousedown", () => {
      currentColor = "red";
      updateToolButtons("penRed");
    });
    document.getElementById("penBlue").addEventListener("mousedown", () => {
      currentColor = "blue";
      updateToolButtons("penBlue");
    });
    document.getElementById("eraserBtn").addEventListener("mousedown", () => {
      currentColor = "white";
      updateToolButtons("eraserBtn");
    });
    document.getElementById("lassoBtn").addEventListener("mousedown", () => {
      isLassoMode = !isLassoMode;
      // åˆå›ä½¿ç”¨æ™‚ã€ã‚‚ã—é¸æŠçŸ©å½¢ãŒ null ãªã‚‰åˆæœŸå€¤ã‚’è¨­å®šï¼ˆä¾‹ï¼š50,50,50,50ï¼‰
      if (isLassoMode && !selectRect) {
        selectRect = { x: 50, y: 50, w: 50, h: 50 };
      }
      selectRectOrig = null;
      lastDragPos = null;
      selectedPaths = [];
      selectedPhotos = [];
      updateToolButtons("lassoBtn");
      document.getElementById("lassoBtn").textContent = isLassoMode ? "æŠ•ã’ç¸„ãƒ„ãƒ¼ãƒ«ON" : "æŠ•ã’ç¸„ãƒ„ãƒ¼ãƒ«OFF";
      redraw();
    });
    document.getElementById("undoBtn").addEventListener("click", undoLocal);
    document.getElementById("redoBtn").addEventListener("click", redoLocal);
    document.getElementById("clearLocalBtn").addEventListener("click", () => {
      clearLocal();
      socket.emit("syncPaths", { roomID, studentId: userID, allPaths: paths });
      socket.emit("syncPhotos", { roomID, studentId: userID, photoObjs: photoObjs });
    });
    const photoInput = document.getElementById("photoInput");
    photoInput.addEventListener("change", handlePhotoSelect);
    
    /*********************
     * pointerã‚¤ãƒ™ãƒ³ãƒˆï¼ˆdrawCanvasç”¨ï¼‰
     *********************/
    drawCanvas.addEventListener("pointerdown", onPointerDown);
    drawCanvas.addEventListener("pointermove", onPointerMove);
    drawCanvas.addEventListener("pointerup", onPointerUp);
    function getPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
    
    function onPointerDown(e) {
      if (!joined || isLocked) return;
      const pos = getPos(e);
      if (isLassoMode) {
        if (selectRect && isInRect(pos, selectRect)) {
          const handleSize = 20;
          const rx = selectRect.x + selectRect.w - handleSize;
          const ry = selectRect.y + selectRect.h - handleSize;
          if (pos.x >= rx && pos.y >= ry) {
            selectMode = "scale";
            selectRectOrig = { ...selectRect };
          } else {
            selectMode = "move";
          }
          lastDragPos = { ...pos };
          return;
        }
        recordSnapshot();
        selectRect = { x: pos.x, y: pos.y, w: 0, h: 0 };
        isDraggingRect = true;
        lastDragPos = { ...pos };
        redraw();
        return;
      }
      recordSnapshot();
      drawing = true;
      paths.push({ color: currentColor, points: [pos] });
      redraw();
    }
    
    function onPointerMove(e) {
      if (!joined || isLocked) return;
      const pos = getPos(e);
      if (isLassoMode) {
        if (isDraggingRect && selectRect) {
          selectRect.w = pos.x - selectRect.x;
          selectRect.h = pos.y - selectRect.y;
          redraw();
          return;
        }
        if (selectMode === "move" && lastDragPos) {
          let dx = pos.x - lastDragPos.x;
          let dy = pos.y - lastDragPos.y;
          selectRect.x += dx;
          selectRect.y += dy;
          moveSelectedObjects(dx, dy);
          lastDragPos = { ...pos };
          redraw();
          return;
        }
        if (selectMode === "scale" && lastDragPos && selectRectOrig) {
          // å‰å›ã¨ã®å·®åˆ†ã§ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«æ›´æ–°
          let dx = pos.x - lastDragPos.x;
          let dy = pos.y - lastDragPos.y;
          // è¨ˆç®—ï¼šå…ƒã®é¸æŠçŸ©å½¢å¹…ãƒ»é«˜ã•ã«å¯¾ã™ã‚‹å·®åˆ†å‰²åˆ
          let factorX = 1 + dx / selectRectOrig.w;
          let factorY = 1 + dy / selectRectOrig.h;
          let uniformFactor = Math.min(factorX, factorY);
          // æ›´æ–°ï¼šé¸æŠçŸ©å½¢ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«æ›´æ–°
          selectRect.w *= uniformFactor;
          selectRect.h *= uniformFactor;
          // å¯¾è±¡ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚åŒã˜å€ç‡ã§æ›´æ–°ï¼ˆå›ºå®šåŸç‚¹ã¯ selectRect.x, selectRect.yï¼‰
          scaleSelectedObjects(uniformFactor, uniformFactor, selectRect.x, selectRect.y);
          lastDragPos = { ...pos };
          redraw();
          return;
        }
      }
      if (drawing) {
        paths[paths.length - 1].points.push(pos);
        redraw();
      }
    }
    
    function onPointerUp(e) {
      if (!joined || isLocked) return;
      if (isLassoMode) {
        if (isDraggingRect) {
          isDraggingRect = false;
          finalizeSelectionRect();
          recordSnapshot();
          socket.emit("syncLasso", { roomID, studentId: userID, selectRect: selectRect });
          socket.emit("syncPhotos", { roomID, studentId: userID, photoObjs: photoObjs });
          console.log("syncLasso emit:", selectRect);
          return;
        }
        if (selectMode) {
          recordSnapshot();
          socket.emit("syncLasso", { roomID, studentId: userID, selectRect: selectRect });
          socket.emit("syncPhotos", { roomID, studentId: userID, photoObjs: photoObjs });
          console.log("syncLasso emit:", selectRect);
          selectMode = null;
          lastDragPos = null;
          return;
        }
      }
      if (drawing) {
        drawing = false;
        recordSnapshot();
      }
    }
    
    function finalizeSelectionRect() {
      if (!selectRect) return;
      let rx = selectRect.w >= 0 ? selectRect.x : selectRect.x + selectRect.w;
      let ry = selectRect.h >= 0 ? selectRect.y : selectRect.y + selectRect.h;
      let rw = Math.abs(selectRect.w);
      let rh = Math.abs(selectRect.h);
      selectRect = { x: rx, y: ry, w: rw, h: rh };
      selectedPaths = [];
      for (let p of paths) {
        let bb = getLineBoundingBox(p);
        if (isRectFullyInsideRect(bb, selectRect)) {
          selectedPaths.push(p);
        }
      }
      selectedPhotos = [];
      for (let obj of photoObjs) {
        let w = obj.width * obj.scale;
        let h = obj.height * obj.scale;
        let bx = { x: obj.x, y: obj.y, w, h };
        if (isRectFullyInsideRect(bx, selectRect)) {
          selectedPhotos.push(obj);
        }
      }
    }
    
    function moveSelectedObjects(dx, dy) {
      for (let p of selectedPaths) {
        for (let pt of p.points) {
          pt.x += dx;
          pt.y += dy;
        }
      }
      for (let obj of selectedPhotos) {
        obj.x += dx;
        obj.y += dy;
      }
    }
    
    function scaleSelectedObjects(sx, sy, ox, oy) {
      for (let p of selectedPaths) {
        for (let pt of p.points) {
          let dx = pt.x - ox, dy = pt.y - oy;
          pt.x = ox + dx * sx;
          pt.y = oy + dy * sy;
        }
      }
      for (let obj of selectedPhotos) {
        let dx = obj.x - ox, dy = obj.y - oy;
        obj.x = ox + dx * sx;
        obj.y = oy + dy * sy;
        obj.scale *= sx; // sx ã¨ sy ã¯åŒã˜å€ç‡
        if (obj.scale < 0.05) obj.scale = 0.05;
        if (obj.scale > 5) obj.scale = 5;
      }
    }
    
    /*********************
     * å†™çœŸè¿½åŠ 
     *********************/
    function handlePhotoSelect(e) {
      console.log("handlePhotoSelect fired");
      const file = e.target.files[0];
      if (!file) return;
      if (photoObjs.length >= 4) {
        alert("å†™çœŸã¯æœ€å¤§4æšã¾ã§ï¼");
        return;
      }
      const reader = new FileReader();
      reader.onload = ev => {
        processImage(ev.target.result);
      };
      reader.onerror = err => {
        console.error("FileReader ã‚¨ãƒ©ãƒ¼", err);
        const fallbackURL = URL.createObjectURL(file);
        processImage(fallbackURL);
      };
      try {
        reader.readAsDataURL(file);
      } catch (err) {
        console.error("readAsDataURL ä¾‹å¤–", err);
        const fallbackURL = URL.createObjectURL(file);
        processImage(fallbackURL);
      }
      e.target.value = "";
    }
    
    function processImage(dataURL) {
      let img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        let p = {
          img: img,
          imgSrc: dataURL,
          x: 40 + photoObjs.length * 30,
          y: 40 + photoObjs.length * 30,
          width: img.width,
          height: img.height,
          scale: 0.1
        };
        if (photoFitMode) {
          let factor = Math.min(800 / img.width, 600 / img.height);
          p.scale = factor;
          p.x = 0;
          p.y = 0;
        }
        photoObjs.push(p);
        recordSnapshot();
        redraw();
        setTimeout(() => {
          socket.emit("syncPhotos", { roomID, studentId: userID, photoObjs: photoObjs });
          console.log("syncPhotos emit:", p);
        }, 500);
      };
      img.onerror = err => {
        console.error("ç”»åƒã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼", err);
      };
      img.src = dataURL;
    }
    
    /*********************
     * æç”»ï¼ˆ2å±¤æ§‹é€ ï¼‰
     *********************/
    function redraw() {
      // ä¸‹å±¤ï¼šå†™çœŸãƒ¬ã‚¤ãƒ¤ãƒ¼
      photoCtx.clearRect(0, 0, photoCanvas.width, photoCanvas.height);
      photoCtx.fillStyle = "#ffffff";
      photoCtx.fillRect(0, 0, photoCanvas.width, photoCanvas.height);
      for (let p of photoObjs) {
        let w = p.width * p.scale;
        let h = p.height * p.scale;
        photoCtx.drawImage(p.img, p.x, p.y, w, h);
      }
      // ä¸Šå±¤ï¼šæç”»ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆç·šï¼‰
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      for (let path of paths) {
        if (path.color === "white") {
          drawCtx.globalCompositeOperation = "destination-out";
          drawCtx.lineWidth = 8;
        } else {
          drawCtx.globalCompositeOperation = "source-over";
          drawCtx.lineWidth = 3;
          drawCtx.strokeStyle = path.color;
        }
        drawCtx.lineCap = "round";
        drawCtx.beginPath();
        if (path.points.length === 0) continue;
        drawCtx.moveTo(path.points[0].x, path.points[0].y);
        for (let i = 1; i < path.points.length; i++) {
          drawCtx.lineTo(path.points[i].x, path.points[i].y);
        }
        drawCtx.stroke();
      }
      // ï¼Šå…ç«¥å´ã§ã¯ã€æŠ•ã’ç¸„ãƒ„ãƒ¼ãƒ«ä½¿ç”¨ä¸­ã¯å¸¸ã«ç ´ç·šã®é¸æŠçŸ©å½¢ã¨å³ä¸‹ãƒãƒ³ãƒ‰ãƒ«ã‚’è¡¨ç¤º
      if (isLassoMode && selectRect) {
        drawCtx.save();
        drawCtx.strokeStyle = "blue";
        drawCtx.setLineDash([5, 5]);
        drawCtx.lineWidth = 2;
        drawCtx.strokeRect(selectRect.x, selectRect.y, selectRect.w, selectRect.h);
        drawCtx.fillStyle = "blue";
        drawCtx.fillRect(selectRect.x + selectRect.w - 10, selectRect.y + selectRect.h - 10, 10, 10);
        drawCtx.restore();
      }
      // åå‰è¡¨ç¤º
      drawCtx.font = "20px sans-serif";
      drawCtx.fillStyle = "rgba(0,0,0,0.5)";
      drawCtx.fillText(userID, 10, 30);
    }
    
    /*********************
     * Undo/Redo
     *********************/
    function recordSnapshot() {
      let snap = JSON.parse(JSON.stringify({ paths, photoObjs, selectRect }));
      undoStack.push(snap);
      redoStack = [];
    }
    function undoLocal() {
      if (undoStack.length < 2) return;
      let popped = undoStack.pop();
      redoStack.push(popped);
      let prev = undoStack[undoStack.length - 1];
      applySnapshot(prev);
    }
    function redoLocal() {
      if (redoStack.length < 1) return;
      let popped = redoStack.pop();
      undoStack.push(popped);
      applySnapshot(popped);
    }
    function applySnapshot(snap) {
      paths = JSON.parse(JSON.stringify(snap.paths));
      photoObjs = JSON.parse(JSON.stringify(snap.photoObjs));
      photoObjs.forEach(photo => {
        if (photo.imgSrc) {
          let img = new Image();
          img.src = photo.imgSrc;
          photo.img = img;
        }
      });
      selectRect = snap.selectRect ? { ...snap.selectRect } : null;
      redraw();
    }
    function clearLocal() {
      if (!joined || isLocked) return;
      recordSnapshot();
      paths = [];
      photoObjs = [];
      selectRect = null;
      redraw();
      recordSnapshot();
    }
    
    /*********************
     * ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
     *********************/
    function isInRect(pt, rect) {
      let x1 = rect.w >= 0 ? rect.x : rect.x + rect.w;
      let y1 = rect.h >= 0 ? rect.y : rect.y + rect.h;
      let w = Math.abs(rect.w), h = Math.abs(rect.h);
      return (pt.x >= x1 && pt.x <= x1 + w && pt.y >= y1 && pt.y <= y1 + h);
    }
    function getLineBoundingBox(path) {
      let xs = path.points.map(p => p.x);
      let ys = path.points.map(p => p.y);
      let minx = Math.min(...xs), maxx = Math.max(...xs);
      let miny = Math.min(...ys), maxy = Math.max(...ys);
      return { x: minx, y: miny, w: maxx - minx, h: maxy - miny };
    }
    function isRectFullyInsideRect(r1, r2) {
      let x1 = r1.x, y1 = r1.y, w1 = r1.w, h1 = r1.h;
      let x2 = r2.x, y2 = r2.y, w2 = r2.w, h2 = r2.h;
      if (w2 < 0) { x2 += w2; w2 = -w2; }
      if (h2 < 0) { y2 += h2; h2 = -h2; }
      if (w1 < 0) { x1 += w1; w1 = -w1; }
      if (h1 < 0) { y1 += h1; h1 = -h1; }
      return (x1 >= x2 && (x1 + w1) <= (x2 + w2) && y1 >= y2 && (y1 + h1) <= (y2 + h2));
    }
    
    // å®šæœŸçš„ã«ç·šãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ï¼ˆ5ç§’ã”ã¨ï¼‰
    setInterval(() => {
      console.log("Emitting syncPaths:", paths);
      if (!joined || isLocked) return;
      socket.emit("syncPaths", { roomID, studentId: userID, allPaths: paths });
    }, 5000);
    
    // ----- LOCK STATE ãƒ‘ãƒƒãƒï¼ˆè²¼ã‚Šä»˜ã‘ã‚‹ã ã‘ã§å‹•ä½œã™ã‚‹è¿½åŠ ã‚³ãƒ¼ãƒ‰ï¼‰ -----
    socket.on("lockState", ({ studentId, locked }) => {
      console.log("lockState received:", studentId, locked);
      if (studentId === userID) {
        isLocked = locked;
        redraw();
      }
    });
    
    // èµ·å‹•æ™‚
    recordSnapshot();
    redraw();
  </script>
</body>
</html>